mitchells@mitchells-ThinkPad-T410:~/Desktop/pequod-v/pequod-cljs$ git diff
diff --git a/src/cljs/pequod_cljs/core.cljs b/src/cljs/pequod_cljs/core.cljs
index 2941ec4..6ff567f 100644
--- a/src/cljs/pequod_cljs/core.cljs
+++ b/src/cljs/pequod_cljs/core.cljs
@@ -3,30 +3,35 @@
               [secretary.core :as secretary :include-macros true]
               [accountant.core :as accountant]
               [pequod-cljs.ex001data :as ex001]
+              [pequod-cljs.ex1dot3 :as ex1dot3]
               [goog.string :as gstring]
               [goog.string.format]))
 
 (def globals
-  (atom {:init-final-price        100
+  (atom {:init-private-good-price 100
          :init-intermediate-price 100
          :init-labor-price        150
          :init-nature-price       150
-         :finals                    4
+         :init-pollutant-price     10
+         :private-goods             4
          :inputs                    4
          :resources                 1
          :labors                    1
-         :final-prices             []
-         :input-prices             []
+         :num-pollutants            1
+         :private-good-prices      []
+         :intermediate-good-prices []
          :labor-prices             []
          :nature-prices            []
+         :pollutant-prices         []
          :old-final-prices         []
          :old-input-prices         []
          :old-nature-prices        []
          :old-labor-prices         []
-         :final-surpluses          []
-         :input-surpluses          []
+         :private-good-surpluses   []
+         :intermediate-good-surpluses []
          :nature-surpluses         []
          :labor-surpluses          []
+         :pollutant-surpluses      []
          :threshold-met            false
          :pdlist                   []
          :delta-delay              0
@@ -38,7 +43,8 @@
          :ccs                      []
          :iteration                0
          :natural-resources-supply 0
-         :labor-supply             0}))
+         :labor-supply             0
+         :pollutant-supply         0}))
 
 (defn standardize-prices [t]
   (assoc t
@@ -55,17 +61,20 @@
     :init-labor-price (+ 30 (rand-nth (range 0 30)))))
 
 (defn initialize-prices [t]
-  (let [finals (t :finals)
+  (let [private-goods (t :private-goods)
         inputs (t :inputs)
         resources (t :resources)
-        labor (t :labors)]
+        labor (t :labors)
+        num-pollutants (t :num-pollutants)]
     (assoc t
-      :final-prices (vec (repeat finals (t :init-final-price)))
-      :input-prices (vec (repeat inputs (t :init-intermediate-price)))
+      :private-good-prices (vec (repeat private-goods (t :init-private-good-price)))
+      :intermediate-good-prices (vec (repeat inputs (t :init-intermediate-price)))
       :nature-prices (vec (repeat resources (t :init-nature-price)))
       :labor-prices (vec (repeat labor (t :init-labor-price)))
-      :price-deltas (vec (repeat 4 0.05))
-      :pdlist (vec (repeat (+ finals inputs resources labor) 0.05)))))
+      :pollutant-prices (vec (repeat num-pollutants (t :init-pollutant-price)))
+      :price-deltas (vec (repeat 5 0.05))
+      :pdlist (vec (repeat (+ private-goods inputs resources labor num-pollutants) 0.05)))))
+
 
 (defn create-ccs [consumer-councils workers-per-council finals]
   (let [effort 1
@@ -162,30 +171,24 @@
   (let [intermediate-inputs (vec (range 1 (inc (t :inputs))))
         nature-types (vec (range 1 (inc (t :resources))))
         labor-types (vec (range 1 (inc (t :labors))))
-        final-goods (vec (range 1 (inc (t :finals))))
-        ccs (create-ccs 100 10 4)]
+        private-goods (vec (range 1 (inc (t :private-goods))))
+        pollutant-types (vec (range 1 (inc (t :num-pollutants))))]
     (-> t
         initialize-prices
         (assoc :price-delta 0.1
                :delta-delay 5
                :natural-resources-supply 1000
                :labor-supply 1000
-               :final-goods final-goods
+               :pollutant-supply 100
+               :private-goods private-goods
                :intermediate-inputs intermediate-inputs
                :nature-types nature-types
                :labor-types labor-types
+               :pollutant-types pollutant-types
                :surplus-threshold 0.02
-               :ccs (if (= button-type "random") ccs ex001/ccs)
-               :wcs
-                 (if (= button-type "ex001") ex001/wcs
-                   (->> (merge (create-wcs 80 final-goods 0)
-                               (create-wcs 80 intermediate-inputs 1))
-                        flatten
-                        (map (partial continue-setup-wcs
-                                      intermediate-inputs
-                                      nature-types
-                                      labor-types))))
-               :lorenz-gini-tuple (update-lorenz-and-gini ccs)))))
+               :ccs ex1dot3/ccs
+               :wcs ex1dot3/wcs
+               ))))
 
 
 (defn adjust-exponents [wc]
@@ -224,20 +227,36 @@
                     (mapv adjust-exponents ex001/wcs))))
 
 
-(defn consume [final-goods final-prices cc]
+(defn consume [private-goods private-good-prices pollutants pollutant-prices num-of-ccs cc]
   (let [utility-exponents (cc :utility-exponents)
-        income (cc :income) 
-        final-demands (map (fn [final-good]
-                             (/ (* income (nth utility-exponents (dec final-good)))
-                                (* (apply + utility-exponents)
-                                   (nth final-prices (dec final-good)))))
-                      final-goods)]
-    (assoc cc :final-demands final-demands)))
+        pollution-supply-coefficients (cc :pollution-supply-coefficients)
+        income (cc :income)
+        all-exponents (->> pollution-supply-coefficients
+                           (concat utility-exponents))
+        final-demands (mapv (fn [final-good]
+                              (/ (* income (nth utility-exponents (dec final-good)))
+                                 (* (+ (apply + utility-exponents)
+                                       (- (apply + pollution-supply-coefficients)))
+                                    (nth private-good-prices (dec final-good)))))
+                            private-goods)
+        pollutant-supply (mapv (fn [pollutant]
+                                 (/ (* income (nth pollution-supply-coefficients (dec pollutant)))
+                                    (* (+ (apply + utility-exponents)
+                                          (- (apply + pollution-supply-coefficients)))
+                                       (/ (nth pollutant-prices (dec pollutant))
+                                          num-of-ccs))))
+                               pollutants)]
+    (assoc cc :final-demands final-demands
+              :pollutant-supply pollutant-supply
+              :income (+ income
+                         (* (/ (first pollutant-supply) num-of-ccs)
+                            (first pollutant-prices))))))
 
 
 (defn assign-new-proposal [production-inputs xs]
   (let [num-input-quantities (count (first production-inputs))
         num-nature-quantities (count (second production-inputs))
+        num-labor-quantities (count (nth production-inputs 2))
         input-quantities (->> xs
                               (take num-input-quantities)
                               (into []))
@@ -247,8 +266,12 @@
                                (into []))
         labor-quantities (->> xs
                               (drop (+ num-input-quantities num-nature-quantities))
+                              (take num-labor-quantities)
+                              (into []))
+        pollutant-demand (->> xs
+                              (drop (+ num-input-quantities num-nature-quantities num-labor-quantities)) 
                               (into []))]
-    [input-quantities nature-quantities labor-quantities]))
+    [input-quantities nature-quantities labor-quantities pollutant-demand]))
 
 
 (defn solution-1 [a s c k ps b λ p-i]
@@ -257,13 +280,14 @@
         output (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ)))) (+ c (- k) (* k b1))))
         x1 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* c (Math/log b1)) (- (* k (Math/log b1))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* c (Math/log p1))) (* k (Math/log p1)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1))))
         effort (Math/pow Math/E (/ (+ (- (* (Math/log a))) (- (* b1 (Math/log b1))) (- (* (Math/log c))) (* b1 (Math/log c)) (* (Math/log k)) (- (* b1 (Math/log k))) (* b1 (Math/log p1)) (* (Math/log s)) (- (* b1 (Math/log s))) (- (* (Math/log λ)))) (+ c (- k) (* k b1))))
-        [input-qs nature-qs labor-qs] (assign-new-proposal p-i [x1])]
+        [input-qs nature-qs labor-qs pollutant-demand] (assign-new-proposal p-i [x1])]
     {:output output
      :x1 x1
      :effort effort
      :input-quantities input-qs
      :nature-quantities nature-qs
-     :labor-quantities labor-qs}))
+     :labor-quantities labor-qs
+     :pollutant-demand pollutant-demand}))
 
 
 (defn solution-2 [a s c k ps b λ p-i]
@@ -273,14 +297,15 @@
         x1 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* c (Math/log b1)) (- (* k (Math/log b1))) (* b2 k (Math/log b1)) (- (* b2 k (Math/log b2))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* c (Math/log p1))) (* k (Math/log p1)) (- (* b2 k (Math/log p1))) (* b2 k (Math/log p2)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2))))
         x2 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (* c (Math/log b2)) (- (* k (Math/log b2))) (* b1 k (Math/log b2)) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (- (* c (Math/log p2))) (* k (Math/log p2)) (- (* b1 k (Math/log p2))) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2))))
         effort (Math/pow Math/E (/ (+ (- (* (Math/log a))) (- (* b1 (Math/log b1))) (- (* b2 (Math/log b2))) (- (* (Math/log c))) (* b1 (Math/log c)) (* b2 (Math/log c)) (* (Math/log k)) (- (* b1 (Math/log k))) (- (* b2 (Math/log k))) (* b1 (Math/log p1)) (* b2 (Math/log p2)) (* (Math/log s)) (- (* b1 (Math/log s))) (- (* b2 (Math/log s))) (- (* (Math/log λ)))) (+ c (- k) (* k b1) (* k b2))))
-        [input-qs nature-qs labor-qs] (assign-new-proposal p-i [x1 x2])]
+        [input-qs nature-qs labor-qs pollutant-demand] (assign-new-proposal p-i [x1 x2])]
     {:output output
      :x1 x1
      :x2 x2
      :effort effort
      :input-quantities input-qs
      :nature-quantities nature-qs
-     :labor-quantities labor-qs}))
+     :labor-quantities labor-qs
+     :pollutant-demand pollutant-demand}))
 
 
 (defn solution-3 [a s c k ps b λ p-i]
@@ -291,7 +316,7 @@
         x2 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (* c (Math/log b2)) (- (* k (Math/log b2))) (* b1 k (Math/log b2)) (* b3 k (Math/log b2)) (- (* b3 k (Math/log b3))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (- (* c (Math/log p2))) (* k (Math/log p2)) (- (* b1 k (Math/log p2))) (- (* b3 k (Math/log p2))) (* b3 k (Math/log p3)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3))))
         x3 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (* c (Math/log b3)) (- (* k (Math/log b3))) (* b1 k (Math/log b3)) (* b2 k (Math/log b3)) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (- (* c (Math/log p3))) (* k (Math/log p3)) (- (* b1 k (Math/log p3))) (- (* b2 k (Math/log p3))) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3))))
         effort (Math/pow Math/E (/ (+ (- (* (Math/log a))) (- (* b1 (Math/log b1))) (- (* b2 (Math/log b2))) (- (* b3 (Math/log b3))) (* b1 (Math/log p1)) (* b2 (Math/log p2)) (* b3 (Math/log p3)) (- (* b1 (Math/log λ))) (- (* b2 (Math/log λ))) (- (* b3 (Math/log λ))) (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3))) (- (/ (* b1 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ)))))  (+ c (- k) (* k b1) (* k b2) (* k b3)))) (- (/ (* b2 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3)))) (- (/ (* b3 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3))))) c))
-        [input-qs nature-qs labor-qs] (assign-new-proposal p-i [x1 x2 x3])]
+        [input-qs nature-qs labor-qs pollutant-demand] (assign-new-proposal p-i [x1 x2 x3])]
     {:output output
      :x1 x1
      :x2 x2
@@ -299,7 +324,8 @@
      :effort effort
      :input-quantities input-qs
      :nature-quantities nature-qs
-     :labor-quantities labor-qs}))
+     :labor-quantities labor-qs
+     :pollutant-demand pollutant-demand}))
 
 
 (defn solution-4 [a s c k ps b λ p-i]
@@ -311,7 +337,7 @@
         x3 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (* c (Math/log b3)) (- (* k (Math/log b3))) (* b1 k (Math/log b3)) (* b2 k (Math/log b3)) (* b4 k (Math/log b3)) (- (* b4 k (Math/log b4))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (- (* c (Math/log p3))) (* k (Math/log p3)) (- (* b1 k (Math/log p3))) (- (* b2 k (Math/log p3))) (- (* b4 k (Math/log p3))) (* b4 k (Math/log p4)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4))))
         x4 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (* c (Math/log b4)) (- (* k (Math/log b4))) (* b1 k (Math/log b4)) (* b2 k (Math/log b4)) (* b3 k (Math/log b4)) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (- (* c (Math/log p4))) (* k (Math/log p4)) (- (* b1 k (Math/log p4))) (- (* b2 k (Math/log p4))) (- (* b3 k (Math/log p4))) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4))))
      effort (Math/pow Math/E (/ (+ (- (* (Math/log a))) (- (* b1 (Math/log b1))) (- (* b2 (Math/log b2))) (- (* b3 (Math/log b3))) (- (* b4 (Math/log b4))) (- (* (Math/log c))) (* b1 (Math/log c)) (* b2 (Math/log c)) (* b3 (Math/log c)) (* b4 (Math/log c)) (* (Math/log k)) (- (* b1 (Math/log k))) (- (* b2 (Math/log k))) (- (* b3 (Math/log k))) (- (* b4 (Math/log k))) (* b1 (Math/log p1)) (* b2 (Math/log p2)) (* b3 (Math/log p3)) (* b4 (Math/log p4)) (* (Math/log s)) (- (* b1 (Math/log s))) (- (* b2 (Math/log s))) (- (* b3 (Math/log s))) (- (* b4 (Math/log s))) (- (* (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4))))
-        [input-qs nature-qs labor-qs] (assign-new-proposal p-i [x1 x2 x3 x4])]
+        [input-qs nature-qs labor-qs pollutant-d] (assign-new-proposal p-i [x1 x2 x3 x4])]
     {:output output
      :x1 x1
      :x2 x2
@@ -320,7 +346,8 @@
      :effort effort
      :input-quantities input-qs
      :nature-quantities nature-qs
-     :labor-quantities labor-qs}))
+     :labor-quantities labor-qs
+     :pollutant-demand pollutant-d}))
 
 (defn solution-5 [a s c k ps b λ p-i]
   (let [[b1 b2 b3 b4 b5] b
@@ -332,7 +359,7 @@
         x4 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (* c (Math/log b4)) (- (* k (Math/log b4))) (* b1 k (Math/log b4)) (* b2 k (Math/log b4)) (* b3 k (Math/log b4)) (* b5 k (Math/log b4)) (- (* b5 k (Math/log b5))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (- (* c (Math/log p4))) (* k (Math/log p4)) (- (* b1 k (Math/log p4))) (- (* b2 k (Math/log p4))) (- (* b3 k (Math/log p4))) (- (* b5 k (Math/log p4))) (* b5 k (Math/log p5)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5))))
         x5 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (* c (Math/log b5)) (- (* k (Math/log b5))) (* b1 k (Math/log b5)) (* b2 k (Math/log b5)) (* b3 k (Math/log b5)) (* b4 k (Math/log b5)) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (- (* c (Math/log p5))) (* k (Math/log p5)) (- (* b1 k (Math/log p5))) (- (* b2 k (Math/log p5))) (- (* b3 k (Math/log p5))) (- (* b4 k (Math/log p5))) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5))))
         effort (Math/pow Math/E (/ (+ (- ( * (Math/log a))) (- (* b1 (Math/log b1))) (- (* b2 (Math/log b2))) (- (* b3 (Math/log b3))) (- (* b4 (Math/log b4))) (- (* b5 (Math/log b5))) (* b1 (Math/log p1)) (* b2 (Math/log p2)) (* b3 (Math/log p3)) (* b4 (Math/log p4)) (* b5 (Math/log p5)) (- (* b1 (Math/log λ))) (- (* b2 (Math/log λ))) (- (* b3 (Math/log λ))) (- (* b4 (Math/log λ))) (- (* b5 (Math/log λ))) (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5))) (- (/ (* b1 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ)))))  (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5)))) (- (/ (* b2 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5)))) (- (/ (* b3 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ)))))  (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5)))) (- (/ (* b4 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5)))) (- (/ (* b5 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5))))) c))
-        [input-qs nature-qs labor-qs] (assign-new-proposal p-i [x1 x2 x3 x4 x5])]
+        [input-qs nature-qs labor-qs pollutant-d] (assign-new-proposal p-i [x1 x2 x3 x4 x5])]
      {:output output
       :x1 x1
       :x2 x2
@@ -342,7 +369,8 @@
       :effort effort
       :input-quantities input-qs
       :nature-quantities nature-qs
-      :labor-quantities labor-qs}))
+      :labor-quantities labor-qs
+      :pollutant-demand pollutant-d}))
 
 
 (defn solution-6 [a s c k ps b λ p-i]
@@ -356,7 +384,34 @@
         x5 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (* c (Math/log b5)) (- (* k (Math/log b5))) (* b1 k (Math/log b5)) (* b2 k (Math/log b5)) (* b3 k (Math/log b5)) (* b4 k (Math/log b5)) (* b6 k (Math/log b5)) (- (* b6 k (Math/log b6))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (- (* c (Math/log p5))) (* k (Math/log p5)) (- (* b1 k (Math/log p5))) (- (* b2 k (Math/log p5))) (- (* b3 k (Math/log p5))) (- (* b4 k (Math/log p5))) (- (* b6 k (Math/log p5))) (* b6 k (Math/log p6)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6))))
         x6 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (* c (Math/log b6)) (- (* k (Math/log b6))) (* b1 k (Math/log b6)) (* b2 k (Math/log b6)) (* b3 k (Math/log b6)) (* b4 k (Math/log b6)) (* b5 k (Math/log b6)) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (- (* c (Math/log p6))) (* k (Math/log p6)) (- (* b1 k (Math/log p6))) (- (* b2 k (Math/log p6))) (- (* b3 k (Math/log p6))) (- (* b4 k (Math/log p6))) (- (* b5 k (Math/log p6))) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6))))
         effort (Math/pow Math/E (/ (+ (- (* (Math/log a))) (- (* b1 (Math/log b1))) (- (* b2 (Math/log b2))) (- (* b3 (Math/log b3))) (- (* b4 (Math/log b4))) (- (* b5 (Math/log b5))) (- (* b6 (Math/log b6))) (- (* (Math/log c))) (* b1 (Math/log c)) (* b2 (Math/log c)) (* b3 (Math/log c)) (* b4 (Math/log c)) (* b5 (Math/log c)) (* b6 (Math/log c)) (* (Math/log k)) (- (* b1 (Math/log k))) (- (* b2 (Math/log k))) (- (* b3 (Math/log k))) (- (* b4 (Math/log k))) (- (* b5 (Math/log k))) (- (* b6 (Math/log k))) (* b1 (Math/log p1)) (* b2 (Math/log p2)) (* b3 (Math/log p3)) (* b4 (Math/log p4)) (* b5 (Math/log p5)) (* b6 (Math/log p6)) (* (Math/log s)) (- (* b1 (Math/log s))) (- (* b2 (Math/log s))) (- (* b3 (Math/log s))) (- (* b4 (Math/log s))) (- (* b5 (Math/log s))) (- (* b6 (Math/log s))) (- (* (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6))))
-        [input-qs nature-qs labor-qs] (assign-new-proposal p-i [x1 x2 x3 x4 x5 x6])]
+        [input-qs nature-qs labor-qs pollutant-d] (assign-new-proposal p-i [x1 x2 x3 x4 x5 x6])]
+     {:output output
+      :x1 x1
+      :x2 x2
+      :x3 x3
+      :x4 x4
+      :x5 x5
+      :x6 x6
+      :effort effort
+      :input-quantities input-qs
+      :nature-quantities nature-qs
+      :labor-quantities labor-qs 
+      :pollutant-demand pollutant-d}))
+
+
+(defn solution-7 [a s c k ps b λ p-i]
+  (let [[b1 b2 b3 b4 b5 b6 b7] b
+        [p1 p2 p3 p4 p5 p6 p7] (flatten ps)
+        output (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* c (Math/log k)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* c (Math/log c))) (- (* b1 k (Math/log b1))) (* b1 k (Math/log p1)) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log b2))) (* b2 k (Math/log p2)) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log b3))) (* b3 k (Math/log p3)) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log b4))) (* b4 k (Math/log p4)) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log b5))) (* b5 k (Math/log p5)) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log b6))) (* b6 k (Math/log p6)) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log b7))) (* b7 k (Math/log p7)) (- (* b7 k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))
+        x1 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* b2 k (Math/log b1)) (* b3 k (Math/log b1)) (* b4 k (Math/log b1)) (* b5 k (Math/log b1)) (* b6 k (Math/log b1)) (* b7 k (Math/log b1)) (* c (Math/log b1)) (- (* k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* b2 k (Math/log p1))) (- (* b3 k (Math/log p1))) (- (* b4 k (Math/log p1))) (- (* b5 k (Math/log p1))) (- (* b6 k (Math/log p1))) (- (* b7 k (Math/log p1))) (* k (Math/log p1)) (- (* c (Math/log p1))) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))
+        x2 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* b1 k (Math/log b2)) (* b3 k (Math/log b2)) (* b4 k (Math/log b2)) (* b5 k (Math/log b2)) (* b6 k (Math/log b2)) (* b7 k (Math/log b2)) (* c (Math/log b2)) (- (* k (Math/log b2))) (- (* b1 k (Math/log b1))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* b1 k (Math/log p2))) (- (* b3 k (Math/log p2))) (- (* b4 k (Math/log p2))) (- (* b5 k (Math/log p2))) (- (* b6 k (Math/log p2))) (- (* b7 k (Math/log p2))) (* k (Math/log p2)) (- (* c (Math/log p2))) (* b1 k (Math/log p1)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))
+        x3 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* b1 k (Math/log b3)) (* b2 k (Math/log b3)) (* b4 k (Math/log b3)) (* b5 k (Math/log b3)) (* b6 k (Math/log b3)) (* b7 k (Math/log b3)) (* c (Math/log b3)) (- (* k (Math/log b3))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* b1 k (Math/log p3))) (- (* b2 k (Math/log p3))) (- (* b4 k (Math/log p3))) (- (* b5 k (Math/log p3))) (- (* b6 k (Math/log p3))) (- (* b7 k (Math/log p3))) (* k (Math/log p3)) (- (* c (Math/log p3))) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))
+        x4 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* b1 k (Math/log b4)) (* b2 k (Math/log b4)) (* b3 k (Math/log b4)) (* b5 k (Math/log b4)) (* b6 k (Math/log b4)) (* b7 k (Math/log b4)) (* c (Math/log b4)) (- (* k (Math/log b4))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* b1 k (Math/log p4))) (- (* b2 k (Math/log p4))) (- (* b3 k (Math/log p4))) (- (* b5 k (Math/log p4))) (- (* b6 k (Math/log p4))) (- (* b7 k (Math/log p4))) (* k (Math/log p4)) (- (* c (Math/log p4))) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))
+        x5 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* b1 k (Math/log b5)) (* b2 k (Math/log b5)) (* b3 k (Math/log b5)) (* b4 k (Math/log b5)) (* b6 k (Math/log b5)) (* b7 k (Math/log b5)) (* c (Math/log b5)) (- (* k (Math/log b5))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* b1 k (Math/log p5))) (- (* b2 k (Math/log p5))) (- (* b3 k (Math/log p5))) (- (* b4 k (Math/log p5))) (- (* b6 k (Math/log p5))) (- (* b7 k (Math/log p5))) (* k (Math/log p5)) (- (* c (Math/log p5))) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))
+        x6 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* b1 k (Math/log b6)) (* b2 k (Math/log b6)) (* b3 k (Math/log b6)) (* b4 k (Math/log b6)) (* b5 k (Math/log b6)) (* b7 k (Math/log b6)) (* c (Math/log b6)) (- (* k (Math/log b6))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* b1 k (Math/log p6))) (- (* b2 k (Math/log p6))) (- (* b3 k (Math/log p6))) (- (* b4 k (Math/log p6))) (- (* b5 k (Math/log p6))) (- (* b7 k (Math/log p6))) (* k (Math/log p6)) (- (* c (Math/log p6))) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))
+        x7 (Math/pow Math/E (/ (+ (- (* k (Math/log a))) (* b1 k (Math/log b7)) (* b2 k (Math/log b7)) (* b3 k (Math/log b7)) (* b4 k (Math/log b7)) (* b5 k (Math/log b7)) (* b6 k (Math/log b7)) (* c (Math/log b7)) (- (* k (Math/log b7))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* c (Math/log c))) (* c (Math/log k)) (- (* b1 k (Math/log p7))) (- (* b2 k (Math/log p7))) (- (* b3 k (Math/log p7))) (- (* b4 k (Math/log p7))) (- (* b5 k (Math/log p7))) (- (* b6 k (Math/log p7))) (* k (Math/log p7)) (- (* c (Math/log p7))) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* c (Math/log s)) (- (* k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))
+        effort (Math/pow Math/E (/ (+ (- (* (Math/log a))) (- (* b1 (Math/log b1))) (- (* b2 (Math/log b2))) (- (* b3 (Math/log b3))) (- (* b4 (Math/log b4))) (- (* b5 (Math/log b5))) (- (* b6 (Math/log b6))) (- (* b7 (Math/log b7))) (* b1 (Math/log p1)) (* b2 (Math/log p2)) (* b3 (Math/log p3)) (* b4 (Math/log p4)) (* b5 (Math/log p5)) (* b6 (Math/log p6)) (* b7 (Math/log p7)) (- (* b1 (Math/log λ))) (- (* b2 (Math/log λ))) (- (* b3 (Math/log λ))) (- (* b4 (Math/log λ))) (- (* b5 (Math/log λ))) (- (* b6 (Math/log λ))) (- (* b7 (Math/log λ))) (/ (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log λ)))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))) (- (/ (* b1 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7)))) (- (/ (* b2 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7)))) (- (/ (* b3 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7)))) (- (/ (* b4 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7)))) (- (/ (* b5 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7)))) (- (/ (* b6 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7)))) (- (/ (* b7 (+ (- (* k (Math/log a))) (- (* b1 k (Math/log b1))) (- (* b2 k (Math/log b2))) (- (* b3 k (Math/log b3))) (- (* b4 k (Math/log b4))) (- (* b5 k (Math/log b5))) (- (* b6 k (Math/log b6))) (- (* b7 k (Math/log b7))) (- (* c (Math/log c))) (* c (Math/log k)) (* b1 k (Math/log p1)) (* b2 k (Math/log p2)) (* b3 k (Math/log p3)) (* b4 k (Math/log p4)) (* b5 k (Math/log p5)) (* b6 k (Math/log p6)) (* b7 k (Math/log p7)) (* c (Math/log s)) (- (* c (Math/log λ))) (- (* b1 k (Math/log λ))) (- (* b2 k (Math/log λ))) (- (* b3 k (Math/log λ))) (- (* b4 k (Math/log λ))) (- (* b5 k (Math/log λ))) (- (* b6 k (Math/log λ))) (- (* b7 k (Math/log λ))))) (+ c (- k) (* k b1) (* k b2) (* k b3) (* k b4) (* k b5) (* k b6) (* k b7))))) c))
+        [input-qs nature-qs labor-qs pollutant-d] (assign-new-proposal p-i [x1 x2 x3 x4 x5 x6 x7])]
      {:output output
       :x1 x1
       :x2 x2
@@ -364,10 +419,12 @@
       :x4 x4
       :x5 x5
       :x6 x6
+      :x7 x7
       :effort effort
       :input-quantities input-qs
       :nature-quantities nature-qs
-      :labor-quantities labor-qs}))
+      :labor-quantities labor-qs
+      :pollutant-demand pollutant-d}))
 
 
 (defn get-input-quantity [f ii [production-inputs input-quantities]]
@@ -382,8 +439,13 @@
     (max 0.001 (min price-delta (abs (* price-delta (nth pdlist J)))))))
 
 
+#_(if (= J 0)
+                                   pollutant-supply
+                                   (/ (reduce + (mapv first (mapv :pollutant-supply ccs)))
+                                       (count ccs)))
+
 (defn update-surpluses-prices
-  [type inputs prices wcs ccs natural-resources-supply labor-supply price-delta pdlist]
+  [type inputs prices wcs ccs natural-resources-supply labor-supply pollutant-supply price-delta pdlist]
   (loop [inputs inputs
          prices prices
          surpluses []
@@ -399,16 +461,18 @@
                                   (reduce +))
                      "intermediate" (->> wcs
                                          (filter #(and (= 1 (% :industry))
-                                                      (= (first inputs)
+                                                       (= (first inputs)
                                                           (% :product))))
                                          (map :output)
                                          (reduce +))
                      "nature" natural-resources-supply
-                     "labor"  labor-supply)
+                     "labor"  labor-supply
+                     "pollutants"  (/ (reduce + (mapv first (mapv :pollutant-supply ccs)))
+                                      (count ccs)))
             demand (condp = type
                      "final" (->> ccs
-                                  (map :final-demands)
-                                  (map #(nth % (dec (first inputs))))
+                                  (mapv :final-demands)
+                                  (mapv #(nth % (dec (first inputs))))
                                   (reduce +))
                      "intermediate" (->> wcs
                                          (filter #(contains? (set (first (:production-inputs %)))
@@ -417,6 +481,7 @@
                                          (map (partial get-input-quantity first inputs))
                                          (reduce +))
                      "nature" (->> wcs
+                                   (filter #(contains? #{0 1} (:industry %)))
                                    (filter #(contains? (set (second (:production-inputs %)))
                                                        (first inputs)))
                                    (map :nature-quantities)
@@ -425,29 +490,41 @@
                      "labor" (->> wcs
                                   #_(filter #(contains? (set (last (:production-inputs %)))
                                                       (first inputs)))
+                                  (filter #(contains? #{0 1} (:industry %)))
                                   (map (juxt :production-inputs :labor-quantities))
                                   (map (partial get-input-quantity last inputs))
-                                  (reduce +)))
+                                  (reduce +))
+                     "pollutants" (->> wcs
+                                       (map :pollutant-demand)
+                                       flatten
+                                       (apply +)))
             j-offset (condp = type
                            "final" 0
                            "intermediate" 4
                            "nature" 8
-                           "labor" 9)
+                           "labor" 9
+                           "pollutants" 10)
             surplus (- supply demand)
             delta (get-deltas (+ j-offset J) price-delta pdlist)
             new-delta (if (or (<= delta 1) (= type "final")) delta
                           (last (take-while (partial < 1)
                                             (iterate #(/ % 2.0) delta))))
-            new-price (cond (pos? surplus) (* (- 1 new-delta) (nth prices (dec (first inputs))))
-                            (neg? surplus) (* (+ 1 new-delta) (nth prices (dec (first inputs))))
-                            :else (nth prices (dec (first inputs))))]
+            new-price (if (= type "pollutants")
+                        (cond (neg? surplus) (* (- 1 new-delta) (nth prices (dec (first inputs))))
+                              (pos? surplus) (* (+ 1 new-delta) (nth prices (dec (first inputs))))
+                              :else (nth prices (dec (first inputs))))
+                        (cond (pos? surplus) (* (- 1 new-delta) (nth prices (dec (first inputs))))
+                              (neg? surplus) (* (+ 1 new-delta) (nth prices (dec (first inputs))))
+                              :else (nth prices (dec (first inputs)))))]
+            (if (= type "pollutants")
+              (println "pollutant - supply demand surplus" supply demand surplus))
         (recur (rest inputs)
                (assoc prices J new-price)
                (conj surpluses surplus)
                (inc J))))))
 
 
-(defn proposal [final-prices input-prices nature-prices labor-prices wc]
+(defn proposal [private-good-prices input-prices nature-prices labor-prices pollutant-prices wc]
   (letfn [(count-inputs [w]
             ((comp count flatten :production-inputs) w))
           (get-input-prices [[indexes prices]]
@@ -457,7 +534,7 @@
                   product (:product w)]
               (cond (= 0 industry) (nth final-prices (dec product))
                     (= 1 industry) (nth input-prices (dec product)))))]
-    (let [prices-and-indexes (->> (vector input-prices nature-prices labor-prices)
+    (let [prices-and-indexes (->> (vector input-prices nature-prices labor-prices pollutant-prices)
                                   (interleave (wc :production-inputs))
                                   (partition 2))
           input-count-r (count-inputs wc)
@@ -469,8 +546,9 @@
           b-input (wc :input-exponents)
           b-labor (wc :labor-exponents)
           b-nature (wc :nature-exponents)
-          b (concat b-input b-nature b-labor)
-          λ (get-lambda-o wc final-prices input-prices)
+          b-pollutant (wc :pollutant-exponents)
+          b (concat b-input b-nature b-labor b-pollutant)
+          λ (get-lambda-o wc private-good-prices input-prices)
           p-i (wc :production-inputs)]
       (condp = input-count-r
         1 (merge wc (solution-1 a s c k ps b λ p-i))
@@ -479,13 +557,14 @@
         4 (merge wc (solution-4 a s c k ps b λ p-i))
         5 (merge wc (solution-5 a s c k ps b λ p-i))
         6 (merge wc (solution-6 a s c k ps b λ p-i))
+        7 (merge wc (solution-7 a s c k ps b λ p-i))
         (str "unexpected input-count value: " input-count-r)))))
 
 
 (defn mean [L]
   (/ (reduce + L) (count L)))
 
-(defn price-change [supply-list demand-list surplus-list]
+(defn update-price-deltas [supply-list demand-list surplus-list]
   (let [supply-list-means (map mean supply-list)
         demand-list-means (map mean demand-list)
         surplus-list-means (map mean surplus-list)
@@ -498,7 +577,7 @@
          (mapv #(Math/abs (/ (first %) (last %)))))))
 
 
-(defn other-price-change [supply-list demand-list surplus-list]
+(defn update-pdlist [supply-list demand-list surplus-list]
   (let [averaged-s-and-d (->> (interleave (flatten supply-list)
                                           (flatten demand-list))
                               (partition 2)
@@ -520,15 +599,18 @@
                                           (second (:production-inputs m))
                                           (:nature-quantities m))
              (merge-inputs-and-quantities :labor-quantity
+                                          (nth (:production-inputs m) 2)
+                                          (:labor-quantities m))
+             (merge-inputs-and-quantities :pollutant-demand
                                           (last (:production-inputs m))
-                                          (:labor-quantities m))])
+                                          (:pollutant-demand m))])
           (sum-input-quantities [qs pos type]
             (->> qs
                  (filter #(and (= pos (:key %)) (= type (:type %))))
                  (map :value)
                  (reduce +)))]
     (let [final-demands (->> t
-                             :final-goods
+                             :private-goods
                              (mapv (fn [i] (mapv #(nth (:final-demands %) (dec i)) (:ccs t))))
                              (mapv (partial reduce +)))
           all-quantities (->> t
@@ -538,11 +620,18 @@
           input-quantity [(sum-input-quantities all-quantities 1 :input-quantity)
                           (sum-input-quantities all-quantities 2 :input-quantity)
                           (sum-input-quantities all-quantities 3 :input-quantity)
-                          (sum-input-quantities all-quantities 4 :input-quantity)]]
+                          (sum-input-quantities all-quantities 4 :input-quantity)]
+          pollutant-demands (->> t
+                                 :wcs
+                                 (map :pollutant-demand)
+                                 flatten
+                                 (apply +)
+                                 vector)]
       [final-demands
        input-quantity
        [(sum-input-quantities all-quantities 1 :nature-quantity)]
-       [(sum-input-quantities all-quantities 1 :labor-quantity)]])))
+       [(sum-input-quantities all-quantities 1 :labor-quantity)]
+       pollutant-demands])))
 
 
 (defn get-supply-list [t]
@@ -554,45 +643,49 @@
                  (map :output)
                  flatten
                  (reduce +)))]
-   (let [final-goods (:final-goods t)
-         final-producers (mapv (partial get-producers t 0) final-goods)
+   (let [private-goods (:private-goods t)
+         final-producers (mapv (partial get-producers t 0) private-goods)
          intermediate-inputs (:intermediate-inputs t)
          input-producers (mapv (partial get-producers t 1) intermediate-inputs)
          natural-resources-supply (vector (:natural-resources-supply t))
-         labor-supply (vector (:labor-supply t))]
-     (vector final-producers input-producers natural-resources-supply labor-supply))))
+         labor-supply (vector (:labor-supply t))
+         pollutant-supply (vector (/ (reduce + (mapv first (mapv :pollutant-supply (:ccs t))))
+                                     (count (:ccs t))))]
+     (vector final-producers input-producers natural-resources-supply labor-supply pollutant-supply))))
 
 
 (defn iterate-plan [t]
-  (let [t2 (assoc t :ccs (map (partial consume (t :final-goods) (t :final-prices))
+  (let [t2 (assoc t :ccs (map (partial consume (t :private-goods) (t :private-good-prices) (t :pollutant-types) (t :pollutant-prices) (count (t :ccs)))
                               (t :ccs))
-                    :wcs (map (partial proposal (t :final-prices) (t :input-prices) (t :nature-prices) (t :labor-prices))
+                    :wcs (map (partial proposal (t :private-good-prices) (t :intermediate-good-prices) (t :nature-prices) (t :labor-prices) (t :pollutant-prices))
                               (t :wcs)))
-        {final-prices :prices, final-surpluses :surpluses} (update-surpluses-prices "final" (t2 :final-goods) (t2 :final-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :price-delta) (t2 :pdlist))
-        {input-prices :prices, input-surpluses :surpluses} (update-surpluses-prices "intermediate" (t2 :intermediate-inputs) (t2 :input-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :price-delta) (t2 :pdlist))
-        {nature-prices :prices, nature-surpluses :surpluses} (update-surpluses-prices "nature" (t2 :nature-types) (t2 :nature-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :price-delta) (t2 :pdlist))
-        {labor-prices :prices, labor-surpluses :surpluses} (update-surpluses-prices "labor" (t2 :labor-types) (t2 :labor-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :price-delta) (t2 :pdlist))
-        surplus-list (vector final-surpluses input-surpluses nature-surpluses labor-surpluses)
+        {private-good-prices :prices, private-good-surpluses :surpluses} (update-surpluses-prices "final" (t2 :private-goods) (t2 :private-good-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :pollutant-supply) (t2 :price-delta) (t2 :pdlist))
+        {input-prices :prices, input-surpluses :surpluses} (update-surpluses-prices "intermediate" (t2 :intermediate-inputs) (t2 :intermediate-good-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :pollutant-supply) (t2 :price-delta) (t2 :pdlist))
+        {nature-prices :prices, nature-surpluses :surpluses} (update-surpluses-prices "nature" (t2 :nature-types) (t2 :nature-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :pollutant-supply) (t2 :price-delta) (t2 :pdlist))
+        {labor-prices :prices, labor-surpluses :surpluses} (update-surpluses-prices "labor" (t2 :labor-types) (t2 :labor-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :pollutant-supply) (t2 :price-delta) (t2 :pdlist))
+        {pollutant-prices :prices, pollutant-surpluses :surpluses} (update-surpluses-prices "pollutants" (t2 :pollutant-types) (t2 :pollutant-prices) (t2 :wcs) (t2 :ccs) (t2 :natural-resources-supply) (t2 :labor-supply) (t2 :pollutant-supply) (t2 :price-delta) (t2 :pdlist))
+        surplus-list (vector private-good-surpluses input-surpluses nature-surpluses labor-surpluses pollutant-surpluses)
         supply-list (get-supply-list t2)
         demand-list (get-demand-list t2)
         new-lorenz-and-gini-tuple (update-lorenz-and-gini (:ccs t2))
-        new-price-deltas (price-change supply-list demand-list surplus-list)
-        new-pdlist (other-price-change supply-list demand-list surplus-list)
+        new-price-deltas (update-price-deltas supply-list demand-list surplus-list)
+        new-pdlist (update-pdlist supply-list demand-list surplus-list)
         iteration (inc (:iteration t2))]
-    (assoc t2 :final-prices final-prices
-              :final-surpluses final-surpluses
-              :input-prices input-prices
-              :input-surpluses input-surpluses
+    (assoc t2 :private-good-prices private-good-prices
+              :private-good-surpluses private-good-surpluses
+              :intermediate-good-prices input-prices
+              :intermediate-good-surpluses input-surpluses
               :nature-prices nature-prices
               :nature-surpluses nature-surpluses
               :labor-prices labor-prices
               :labor-surpluses labor-surpluses
+              :pollutant-prices pollutant-prices
+              :pollutant-surpluses pollutant-surpluses
               :demand-list demand-list
               :surplus-list surplus-list
               :supply-list supply-list
               :price-deltas new-price-deltas
               :pdlist new-pdlist
-              :lorenz-gini-tuple new-lorenz-and-gini-tuple
               :iteration iteration)))
 
 
@@ -607,15 +700,22 @@
                       (* surplus-threshold supply))
                   inputs))
           (get-producers [wcs industry]
-            (filter #(= industry (% :industry))) wcs)]
+            (filter #(= industry (% :industry))) wcs)
+          (get-pollutant-supply [t]
+            (/ (reduce + (mapv first (mapv :pollutant-supply (:ccs t))))
+               (count (:ccs t))))]
     (let [surplus-threshold (:surplus-threshold t)
           final-producers (get-producers (:wcs t) 0)
           input-producers (get-producers (:wcs t) 1)
-          final-goods-check (check-producers (:final-surpluses t) final-producers (:final-goods t))
-          im-goods-check (check-producers (:input-surpluses t) input-producers (:intermediate-inputs t))
+          private-goods-check (check-producers (:private-good-surpluses t) final-producers (:private-goods t))
+          im-goods-check (check-producers (:intermediate-good-surpluses t) input-producers (:intermediate-inputs t))
           nature-check (check-supplies (:nature-surpluses t) (:natural-resources-supply t) (:nature-types t) surplus-threshold)
-          labor-check (check-supplies (:labor-surplus t) (:labor-supply t) (:labor-types t) surplus-threshold)]
-      (every? nil? [final-goods-check im-goods-check nature-check labor-check]))))
+          labor-check (check-supplies (:labor-surpluses t) (:labor-supply t) (:labor-types t) surplus-threshold)
+          pollutant-check (check-supplies (:pollutant-surpluses t) (get-pollutant-supply t) (:pollutant-types t) surplus-threshold)          
+          ]
+     (println "check-supplies:" (:pollutant-surpluses t) (get-pollutant-supply t) (:pollutant-types t) surplus-threshold (* surplus-threshold (get-pollutant-supply t)))
+     [private-goods-check im-goods-check nature-check labor-check pollutant-check]
+     #_(every? nil? [private-goods-check im-goods-check nature-check labor-check pollutant-check]))))
 
 
 (defn total-surplus [surplus-list]
@@ -645,25 +745,27 @@
         delta-delay (:delta-delay t)
         price-delta (:price-delta t)
         {price-delta :price-delta
-         delta-delay :delta-delay} (if (and (< total-surplus 100)
+         delta-delay :delta-delay} (if (and (< surplus-total 100)
                                               (<= delta-delay 0))
                                      (adjust-delta price-delta "lower")
                                      {:price-delta price-delta
                                       :delta-delay delta-delay})
         {price-delta :price-delta
-         delta-delay :delta-delay} (if (and (> total-surplus 100000)
+         delta-delay :delta-delay} (if (and (> surplus-total 100000)
                                               (<= delta-delay 0))
                                      (adjust-delta price-delta "raise")
                                      {:price-delta price-delta
                                       :delta-delay delta-delay})
         delta-delay (if (pos? delta-delay)
-                      (dec delta-delay) delta-delay)]
-    (assoc t :threshold-met threshold
-             :price-delta price-delta
-             :delta-delay delta-delay)))
+                      (dec delta-delay) delta-delay)
+        t-updated (assoc t :threshold-met threshold
+                           :price-delta price-delta
+                           :delta-delay delta-delay)]
+      t-updated))
 
 (defn proceed [t]
-  (rest-of-to-do (iterate-plan t)))
+  (let [t-plus (iterate-plan t)]
+    (rest-of-to-do t-plus)))
 
 ;; -------------------------
 ;; Views-
@@ -672,37 +774,39 @@
   [:input {:type "button" :value "Setup Random"
            :on-click #(swap! globals setup globals "random")}])
 
-(defn setup-ex001-button []
+#_(defn setup-ex001-button []
   [:input {:type "button" :value "Setup Ex001"
            :on-click #(swap! globals setup globals "ex001")}])
 
+(defn setup-1dot3 []
+  [:input {:type "button" :value "Setup"
+           :on-click #(swap! globals setup globals "ex1dot3")}])
+
 (defn iterate-button []
   [:input {:type "button" :value "Iterate and check"
            :on-click #(swap! globals proceed globals)}])
 
-(defn reset-all-but-prices-button-no-exp []
+#_(defn reset-all-but-prices-button-no-exp []
   [:input {:type "button" :value "Reset Ex001: All but prices, no exp. adj."
            :on-click #(swap! globals reset-all-but-prices globals "no-exponent-adjustment")}])
 
-(defn reset-all-but-prices-button-with-exp []
+#_(defn reset-all-but-prices-button-with-exp []
   [:input {:type "button" :value "Reset Ex001: All but prices, with ex. adj."
            :on-click #(swap! globals reset-all-but-prices globals "random-exponent-adjustment")}])
 
 
 #_[:iteration :demand-list :pdlist :input-prices :nature-prices :labor-prices :final-prices :supply-list :threshold-met :nature-surpluses :natural-resources-supply :nature-types :surplus-threshold] 
 (defn show-globals []
-    (let [keys-to-show [:final-prices :threshold-met :delta-delay :price-delta :iteration :final-surpluses :price-deltas :pdlist :input-prices :nature-prices :labor-prices :input-surpluses :nature-surpluses :labor-surpluses :threshold-met :supply-list :demand-list :surplus-list :threshold :surplus-threshold]
+    (let [keys-to-show [:private-good-prices :threshold-met :iteration :price-deltas :intermediate-good-prices :nature-prices :labor-prices :public-good-prices :price-delta :price-deltas :pdlist :pollutant-prices :surplus-list :supply-list :demand-list :pollutant-supply :pollutant-surpluses :pollutant-types :labor-supply]
         ]
      [:div #_" "
            #_(setup-random-button)
            "  "
-           (setup-ex001-button)
+           (setup-1dot3)
            "  "
            (iterate-button)
            "  "
-           (reset-all-but-prices-button-no-exp)
-           "  "
-           (reset-all-but-prices-button-with-exp)
+           
            [:p]
            [:table
             (map (fn [x] [:tr [:td (str (first x))]
@@ -710,14 +814,13 @@
                  (sort (select-keys @globals keys-to-show))
                  )]
            #_[:p]
-           #_ (clojure.string/join " " (sort (keys @globals)))
+           #_(clojure.string/join " " (sort (keys @globals)))
            #_[:p]
-          #_ [:table
+          #_[:table
             (map (fn [x] [:tr [:td (str (first x))]
                           [:td (str (second x))]])
                  (sort @globals))]
-            [:p]
-     ]))
+            #_[:p]]))
 
